<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ†²æ³•æè¡›è€… V11ï¼šæœ€çµ‚ä¿®å¾©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Courier, monospace; touch-action: none; }
        
        /* è¦–çª—å®¹å™¨ */
        .vr-viewport { position: relative; width: 100%; height: 100%; overflow: hidden; perspective: 800px; background: #000; }
        
        /* ä¸–ç•Œå®¹å™¨ */
        .vr-world {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform-style: preserve-3d;
            will-change: transform;
            transform-origin: 50% 50% 0px; 
        }

        /* æ˜Ÿç©º */
        .star-field {
            position: absolute; top: -150%; left: -150%; width: 400%; height: 400%;
            background-image: 
                radial-gradient(2px 2px at 100px 100px, white, transparent),
                radial-gradient(1.5px 1.5px at 300px 400px, rgba(255,255,255,0.7), transparent),
                radial-gradient(2px 2px at 600px 200px, white, transparent);
            background-size: 800px 800px;
            transform: translateZ(-3000px); 
        }

        .reticle-ring { transition: stroke-dashoffset 0.1s linear; transform: rotate(-90deg); transform-origin: 50% 50%; }
        
        /* æº–å¿ƒç„æº–æ™‚çš„å‹•ç•« */
        @keyframes lock-on { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.2); border-color: red; } 100% { transform: translate(-50%, -50%) scale(1); } }
        .locking { animation: lock-on 0.5s infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const questionBank = [
            {
                id: 1,
                text: "ç„æº–ï¼šç›´è½„å¸‚ã€Œè¡Œæ”¿æ©Ÿé—œã€",
                hint: "é—œéµå­—ï¼šå¸‚æ”¿åºœ (åŸ·è¡Œ)",
                targets: [
                    { text: "æ–°åŒ—å¸‚æ”¿åºœ", type: "correct", color: "#3b82f6" },
                    { text: "å°ä¸­å¸‚æ”¿åºœ", type: "correct", color: "#3b82f6" },
                    { text: "é«˜é›„å¸‚æ”¿åºœ", type: "correct", color: "#3b82f6" },
                    { text: "å°åŒ—å¸‚æ”¿åºœ", type: "correct", color: "#3b82f6" },
                    { text: "æ–°åŒ—å¸‚è­°æœƒ", type: "wrong", color: "#ef4444" },
                    { text: "æ¿æ©‹å€å…¬æ‰€", type: "wrong", color: "#6b7280" },
                    { text: "å°ä¸­å¸‚è­°æœƒ", type: "wrong", color: "#ef4444" }
                ]
            },
            {
                id: 2,
                text: "ç„æº–ï¼šç¸£å¸‚ã€Œç«‹æ³•æ©Ÿé—œã€",
                hint: "é—œéµå­—ï¼šè­°æœƒ (ç›£ç£)",
                targets: [
                    { text: "èŠ±è“®ç¸£è­°æœƒ", type: "correct", color: "#a855f7" },
                    { text: "å˜‰ç¾©ç¸£è­°æœƒ", type: "correct", color: "#a855f7" },
                    { text: "æ–°ç«¹å¸‚è­°æœƒ", type: "correct", color: "#a855f7" },
                    { text: "å½°åŒ–ç¸£è­°æœƒ", type: "correct", color: "#a855f7" },
                    { text: "èŠ±è“®ç¸£æ”¿åºœ", type: "wrong", color: "#ef4444" },
                    { text: "å°æ±ç¸£æ”¿åºœ", type: "wrong", color: "#ef4444" },
                    { text: "å®œè˜­å¸‚å…¬æ‰€", type: "wrong", color: "#6b7280" }
                ]
            },
            {
                id: 3,
                text: "ç„æº–ï¼šå±±åœ°åŸä½æ°‘å€",
                hint: "é—œéµï¼šå€å…¬æ‰€ / è‡ªæ²»",
                targets: [
                    { text: "çƒä¾†å€å…¬æ‰€", type: "correct", color: "#22c55e" },
                    { text: "å’Œå¹³å€å…¬æ‰€", type: "correct", color: "#22c55e" },
                    { text: "èŒ‚æ—å€å…¬æ‰€", type: "correct", color: "#22c55e" },
                    { text: "é‚£ç‘ªå¤å€å…¬æ‰€", type: "correct", color: "#22c55e" },
                    { text: "å¤§å®‰å€å…¬æ‰€", type: "wrong", color: "#6b7280" },
                    { text: "ä¸­å’Œå€å…¬æ‰€", type: "wrong", color: "#6b7280" },
                    { text: "ä¿¡ç¾©å€å…¬æ‰€", type: "wrong", color: "#6b7280" }
                ]
            }
        ];

        // ğŸ›¸ ç´”ç¨® UFO (å¹¾ä½•åœ–å½¢)
        const RealUFO = ({ color, text, variant }) => {
            const renderShip = () => {
                if (variant === 0) {
                    return (
                        <svg viewBox="0 0 100 50" className="w-32 h-16 drop-shadow-[0_0_15px_rgba(255,255,255,0.9)]">
                            <path d="M10 25 Q50 -10 90 25 Q50 60 10 25 Z" fill={color} stroke="white" strokeWidth="2" />
                            <ellipse cx="50" cy="15" rx="15" ry="6" fill="rgba(255,255,255,0.8)" />
                            <circle cx="20" cy="25" r="3" fill="#ff0" className="animate-ping" />
                            <circle cx="80" cy="25" r="3" fill="#ff0" className="animate-ping" style={{animationDelay: '0.5s'}} />
                        </svg>
                    );
                } else if (variant === 1) {
                    return (
                        <svg viewBox="0 0 100 60" className="w-28 h-20 drop-shadow-[0_0_15px_rgba(255,255,255,0.9)]">
                            <path d="M10 20 L30 10 L70 10 L90 20 L70 50 L30 50 Z" fill={color} stroke="white" strokeWidth="2" />
                            <rect x="45" y="50" width="10" height="5" fill="orange" className="animate-pulse" />
                        </svg>
                    );
                } else {
                    return (
                        <svg viewBox="0 0 100 100" className="w-28 h-28 drop-shadow-[0_0_15px_rgba(255,255,255,0.9)]">
                            <path d="M50 0 L90 80 L50 60 L10 80 Z" fill={color} stroke="white" strokeWidth="2" />
                            <circle cx="50" cy="60" r="8" fill="cyan" style={{opacity: 0.8}} />
                        </svg>
                    );
                }
            };
            return (
                <div className="flex flex-col items-center">
                    {renderShip()}
                    <div className="mt-1 bg-black/60 border border-white/40 text-white px-2 py-0.5 rounded text-xl font-bold whitespace-nowrap backdrop-blur-sm">
                        {text}
                    </div>
                </div>
            );
        };

        const EyeView = ({ isLeft, gameState, score, health, currentQ, enemies, focusingId, focusProgress, currentViewX, currentViewY }) => {
            // è¦–è§’æ§åˆ¶ï¼šå°‡ World åå‘æ—‹è½‰ï¼Œç‡Ÿé€ æ”å½±æ©Ÿè½‰å‹•çš„æ„Ÿè¦º
            const worldStyle = {
                transform: `rotateX(${currentViewY}deg) rotateY(${currentViewX}deg)`
            };

            return (
                <div className={`vr-viewport border-r-2 border-gray-800 ${isLeft ? '' : 'border-l-0'}`}>
                    <div className="vr-world" style={worldStyle}>
                        <div className="star-field"></div>
                        {gameState === 'playing' && enemies.map(enemy => (
                            <div
                                key={enemy.id}
                                className="absolute top-1/2 left-1/2 flex flex-col items-center justify-center will-change-transform"
                                style={{
                                    // 3D ç©ºé–“å®šä½
                                    transform: `translateX(${enemy.x}vw) translateY(${enemy.y}vh) translateZ(${enemy.z}px)`,
                                    opacity: enemy.z > -200 ? 0 : 1,
                                    filter: focusingId === enemy.id ? 'drop-shadow(0 0 40px #facc15)' : 'none' // é–å®šæ™‚ç™¼å…‰
                                }}
                            >
                                <RealUFO color={enemy.color} text={enemy.text} variant={enemy.variant} />
                            </div>
                        ))}
                    </div>

                    {/* ç„æº–æº–å¿ƒ (å›ºå®šåœ¨æ­£ä¸­å¤®) */}
                    <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none">
                        <svg width="60" height="60" viewBox="0 0 60 60" className={focusingId ? "locking" : ""}>
                            <circle cx="30" cy="30" r="3" fill={focusingId ? "red" : "#0f0"} />
                            <circle cx="30" cy="30" r="25" fill="none" stroke={focusingId ? "red" : "#0f0"} strokeWidth="3"
                                strokeDasharray="157" strokeDashoffset={157 - (157 * focusProgress / 100)}
                                className="reticle-ring" opacity={focusProgress > 0 ? 1 : 0.3} />
                        </svg>
                    </div>

                    {/* HUD */}
                    <div className={`absolute inset-0 pointer-events-none z-40 transition-colors duration-100 ${health < 30 ? 'bg-red-900/40 animate-pulse' : ''}`}></div>

                    <div className="absolute top-8 left-0 w-full flex justify-center z-20 pointer-events-none">
                        <div className="bg-black/70 border-2 border-green-500 px-6 py-2 rounded-full backdrop-blur-md">
                            <div className="text-yellow-400 text-2xl font-bold">{currentQ.text}</div>
                        </div>
                    </div>

                    <div className="absolute bottom-10 w-full flex justify-between px-16 z-20 text-xl font-bold font-mono">
                        <div className="text-green-400">SCORE: {score}</div>
                        <div className={health < 40 ? "text-red-500" : "text-blue-400"}>SHIELD: {health}%</div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [gameState, setGameState] = useState('start'); 
            const [mode, setMode] = useState('single'); 
            const [score, setScore] = useState(0);
            const [health, setHealth] = useState(100);
            const [level, setLevel] = useState(0);
            
            // ä½¿ç”¨ Ref ä¾†å„²å­˜ä¸æœƒè§¸ç™¼é‡ç¹ªçš„éŠæˆ²é‚è¼¯æ•¸æ“š (è§£æ±º bug çš„é—œéµ!)
            const enemiesRef = useRef([]);
            // å¼·åˆ¶ React æ›´æ–°ç•«é¢ç”¨çš„
            const [renderEnemies, setRenderEnemies] = useState([]); 

            // è¦–è§’ Ref (è§£æ±ºæ•ˆèƒ½å•é¡Œ)
            const viewRef = useRef({ x: 0, y: 0 });
            // ç”¨ State ä¾†è§¸ç™¼ç•«é¢æ—‹è½‰
            const [viewState, setViewState] = useState({ x: 0, y: 0 });

            // è§¸æ§æ‹–æ›³ Ref
            const touchRef = useRef({ startX: 0, startY: 0, isDragging: false, lastX: 0, lastY: 0 });
            // é™€èºå„€åŸºæº– Ref
            const gyroRef = useRef({ baseBeta: null, baseGamma: null });

            // å‡è¦–ç³»çµ±
            const [focusingId, setFocusingId] = useState(null);
            const [focusProgress, setFocusProgress] = useState(0);
            const focusTimerRef = useRef(0);
            const lastFocusIdRef = useRef(null);

            const lastTimeRef = useRef(0);
            const lastSpawnTimeRef = useRef(0);
            const frameRef = useRef();

            const currentQ = questionBank[level];

            // é™€èºå„€è™•ç†
            const handleOrientation = (event) => {
                const beta = event.beta || 0;
                const gamma = event.gamma || 0;

                if (gyroRef.current.baseBeta === null) {
                    gyroRef.current.baseBeta = beta;
                    gyroRef.current.baseGamma = gamma;
                }

                if (!touchRef.current.isDragging) {
                    // é™€èºå„€ç›´æ¥å½±éŸ¿ View Refï¼Œä¸ä¾è³´ State (é¿å…é–‰åŒ…é™·é˜±)
                    const deltaX = gamma - gyroRef.current.baseGamma;
                    const deltaY = beta - gyroRef.current.baseBeta;
                    
                    // åŠ ä¸Šæ‰‹å‹•æ‹–æ›³çš„åç§»é‡
                    viewRef.current.x = -deltaX + touchRef.current.lastX; 
                    viewRef.current.y = deltaY + touchRef.current.lastY;
                }
            };

            // è§¸æ§è™•ç† (æ»‘å‹•ç„æº–)
            const handleTouchStart = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                touchRef.current.startX = clientX;
                touchRef.current.startY = clientY;
                touchRef.current.isDragging = true;
            };

            const handleTouchMove = (e) => {
                if (!touchRef.current.isDragging) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const deltaX = (clientX - touchRef.current.startX) * 0.3;
                const deltaY = (clientY - touchRef.current.startY) * 0.3;

                // ç›´æ¥æ›´æ–° View Ref
                // æ³¨æ„ï¼šé€™è£¡æ˜¯åŠ ä¸Šå»ï¼Œä¸æ˜¯å–ä»£
                viewRef.current.x += deltaX; 
                viewRef.current.y -= deltaY; // Yè»¸åè½‰

                // é™åˆ¶ä¸Šä¸‹è§’åº¦
                viewRef.current.y = Math.max(-60, Math.min(60, viewRef.current.y));

                touchRef.current.startX = clientX;
                touchRef.current.startY = clientY;
            };

            const handleTouchEnd = () => {
                touchRef.current.isDragging = false;
                touchRef.current.lastX = viewRef.current.x;
                touchRef.current.lastY = viewRef.current.y;
                // é‡ç½®é™€èºå„€åŸºæº–ï¼Œé¿å…è·³å‹•
                gyroRef.current.baseBeta = null; 
            };

            const requestPermission = async () => {
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const r = await DeviceOrientationEvent.requestPermission();
                        if(r === 'granted') window.addEventListener('deviceorientation', handleOrientation);
                    } catch (e) { console.error(e); }
                } else {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            };

            // ç”Ÿæˆæ•µäºº (ç´”æ•¸æ“šæ“ä½œ)
            const spawnEnemy = () => {
                const isCorrect = Math.random() > 0.45;
                const targetPool = isCorrect 
                    ? currentQ.targets.filter(t => t.type === 'correct') 
                    : currentQ.targets.filter(t => t.type === 'wrong');
                const template = targetPool[Math.floor(Math.random() * targetPool.length)];
                
                const startX = (Math.random() - 0.5) * 250; 
                const startY = (Math.random() - 0.5) * 120;

                enemiesRef.current.push({
                    id: Date.now() + Math.random(),
                    ...template,
                    x: startX,
                    y: startY,
                    z: -3000, 
                    variant: Math.floor(Math.random() * 3),
                    speed: 12 + (level * 2) 
                });
            };

            // éŠæˆ²ä¸»è¿´åœˆ
            const gameLoop = (time) => {
                if (gameState !== 'playing') return;
                const deltaTime = time - lastTimeRef.current;
                lastTimeRef.current = time;

                // 1. ç”Ÿæˆé‚è¼¯ (æª¢æŸ¥æ™‚é–“å·®)
                if (time - lastSpawnTimeRef.current > 1500) { // 1.5ç§’ä¸€éš»
                    spawnEnemy();
                    lastSpawnTimeRef.current = time;
                }

                let hitId = null;
                let closestId = null;
                // æ“´å¤§åˆ¤å®šç¯„åœï¼Œè®“æ‰‹æŒ‡æ»‘å‹•æ›´å®¹æ˜“å°æº–
                const aimThreshold = 50; 

                // 2. æ›´æ–°æ‰€æœ‰æ•µäººä½ç½®
                enemiesRef.current.forEach(enemy => {
                    // ç§»å‹•
                    enemy.z += enemy.speed * (deltaTime / 16);

                    // ç„æº–åˆ¤å®š
                    // è¦–è§’ X å°æ‡‰æ•µäººçš„ X (åå‘)
                    // è¦–è§’ Y å°æ‡‰æ•µäººçš„ Y
                    const diffX = enemy.x - (-viewRef.current.x);
                    const diffY = enemy.y - (viewRef.current.y);
                    const dist = Math.sqrt(diffX*diffX + diffY*diffY);

                    // åˆ¤æ–·æ˜¯å¦åœ¨æº–å¿ƒé™„è¿‘
                    if (dist < aimThreshold && enemy.z > -2500 && enemy.z < -300) {
                        closestId = enemy.id;
                    }
                });

                // 3. ç§»é™¤æ’æ“Šæˆ–éé ­çš„æ•µäºº
                // å…ˆæ‰£è¡€
                enemiesRef.current.forEach(e => {
                    if (e.z > -100 && !e.processed) {
                        e.processed = true; // æ¨™è¨˜å·²è™•ç†ï¼Œé¿å…é‡è¤‡æ‰£è¡€
                        if (e.type === 'correct') {
                            setHealth(h => {
                                const newH = Math.max(0, h - 15);
                                if (newH <= 0) setGameState('gameover');
                                return newH;
                            });
                        }
                    }
                });
                // å†éæ¿¾
                enemiesRef.current = enemiesRef.current.filter(e => e.z <= 100);

                // 4. å‡è¦–é‚è¼¯
                if (closestId) {
                    if (closestId !== lastFocusIdRef.current) {
                        lastFocusIdRef.current = closestId;
                        focusTimerRef.current = 0;
                        setFocusingId(closestId);
                        setFocusProgress(0);
                    } else {
                        focusTimerRef.current += deltaTime;
                        const progress = Math.min(100, (focusTimerRef.current / 1000) * 100); // 1ç§’é–å®š
                        setFocusProgress(progress);
                        
                        if (focusTimerRef.current >= 1000) {
                            hitId = closestId;
                            lastFocusIdRef.current = null;
                            focusTimerRef.current = 0;
                            setFocusingId(null);
                            setFocusProgress(0);
                        }
                    }
                } else {
                    lastFocusIdRef.current = null;
                    setFocusingId(null);
                    setFocusProgress(0);
                }

                // 5. å‘½ä¸­è™•ç†
                if (hitId) {
                    const hitEnemy = enemiesRef.current.find(e => e.id === hitId);
                    if (hitEnemy) {
                        if (hitEnemy.type === 'correct') {
                            setScore(s => {
                                const newS = s + 100;
                                if ((newS) % 500 === 0 && level < questionBank.length - 1) {
                                    setLevel(l => l + 1);
                                    enemiesRef.current = []; // æ¸…å ´
                                } else if (newS >= questionBank.length * 500) {
                                    setGameState('win');
                                }
                                return newS;
                            });
                        } else {
                            setHealth(h => {
                                const newH = Math.max(0, h - 20);
                                if (newH <= 0) setGameState('gameover');
                                return newH;
                            });
                            if (navigator.vibrate) navigator.vibrate(200);
                        }
                        // ç§»é™¤è¢«æ‰“ä¸­çš„
                        enemiesRef.current = enemiesRef.current.filter(e => e.id !== hitId);
                    }
                }

                // 6. åŒæ­¥ç•«é¢
                setRenderEnemies([...enemiesRef.current]);
                setViewState({ ...viewRef.current });

                if (gameState === 'playing') {
                    frameRef.current = requestAnimationFrame(gameLoop);
                }
            };

            // å•Ÿå‹•èˆ‡æš«åœ
            useEffect(() => {
                if (gameState === 'playing') {
                    lastTimeRef.current = performance.now();
                    lastSpawnTimeRef.current = performance.now();
                    frameRef.current = requestAnimationFrame(gameLoop);
                } else {
                    cancelAnimationFrame(frameRef.current);
                }
                return () => cancelAnimationFrame(frameRef.current);
            }, [gameState]); // åªä¾è³´ gameStateï¼Œé¿å…è¢«å…¶ä»– state é‡ç½®è¿´åœˆ

            const startGame = async (m) => {
                await requestPermission();
                setMode(m);
                // é‡ç½®æ‰€æœ‰ Ref æ•¸æ“š
                enemiesRef.current = [];
                viewRef.current = { x: 0, y: 0 };
                touchRef.current.lastX = 0;
                touchRef.current.lastY = 0;
                
                setScore(0);
                setHealth(100);
                setLevel(0);
                setGameState('playing');
            };

            // UI æ¸²æŸ“
            if (gameState === 'start' || gameState === 'gameover' || gameState === 'win') {
                return (
                    <div className="flex flex-col items-center justify-center h-screen bg-black text-white font-mono p-4 text-center bg-[url('https://images.unsplash.com/photo-1475274047050-1d0c0975c63e?ixlib=rb-4.0.3&auto=format&fit=crop&w=2342&q=80')] bg-cover bg-center">
                        <div className="bg-black/90 p-8 rounded-2xl border border-blue-500/50 w-full max-w-md">
                            <h1 className="text-4xl font-bold mb-2 text-blue-400">æ†²æ³•æè¡›è€… V11</h1>
                            <p className="text-gray-300 mb-6">æœ€çµ‚ä¿®å¾©ç‰ˆ</p>
                            
                            {gameState !== 'start' && <div className="text-4xl mb-6 text-yellow-400 font-bold">SCORE: {score}</div>}

                            <div className="space-y-4">
                                <button onClick={() => startGame('single')} className="w-full py-4 bg-gray-700 border-2 border-blue-500 rounded-xl font-bold hover:bg-gray-600 transition">
                                    ğŸ“± å–®è¢å¹• (æ‰‹æŒ)
                                </button>
                                <button onClick={() => startGame('vr')} className="w-full py-4 bg-blue-600 rounded-xl font-bold shadow-[0_0_20px_#2563eb] hover:bg-blue-700 transition">
                                    ğŸ‘“ VR çœ¼é¡ (æ”¾å…¥ç´™ç›’)
                                </button>
                            </div>
                            <p className="mt-6 text-xs text-gray-400">
                                ğŸ’¡ æº–å¿ƒæ˜¯å›ºå®šçš„ï¼Œè«‹è½‰å‹•æ‰‹æ©Ÿæˆ–<b>æ»‘å‹•è¢å¹•</b>ä¾†æŠŠæ•µäººå¥—å…¥æº–å¿ƒã€‚
                            </p>
                        </div>
                    </div>
                );
            }

            return (
                <div 
                    className="w-full h-screen bg-black flex overflow-hidden cursor-move"
                    onTouchStart={handleTouchStart}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                    onMouseDown={handleTouchStart}
                    onMouseMove={handleTouchMove}
                    onMouseUp={handleTouchEnd}
                >
                    {mode === 'vr' ? (
                        <>
                            <div className="w-1/2 h-full relative overflow-hidden">
                                <EyeView isLeft={true} {...{gameState, score, health, currentQ, enemies: renderEnemies, focusingId, focusProgress, currentViewX: viewState.x, currentViewY: viewState.y}} />
                            </div>
                            <div className="w-1/2 h-full relative overflow-hidden">
                                <EyeView isLeft={false} {...{gameState, score, health, currentQ, enemies: renderEnemies, focusingId, focusProgress, currentViewX: viewState.x, currentViewY: viewState.y}} />
                            </div>
                            <div className="absolute top-1/2 left-1/2 w-[1px] h-10 bg-white/30 transform -translate-x-1/2 -translate-y-1/2"></div>
                        </>
                    ) : (
                        <div className="w-full h-full relative overflow-hidden">
                            <EyeView isLeft={true} {...{gameState, score, health, currentQ, enemies: renderEnemies, focusingId, focusProgress, currentViewX: viewState.x, currentViewY: viewState.y}} />
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
